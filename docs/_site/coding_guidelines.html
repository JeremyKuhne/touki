<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Coding Style </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Coding Style ">
    
      <link rel="shortcut icon" href="favicon.ico">
      <link rel="stylesheet" href="styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="styles/docfx.css">
      <link rel="stylesheet" href="styles/main.css">
      <link rel="stylesheet" href="styles/dark.css">
      <meta property="docfx:navrel" content="toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="Touki">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="coding-style">Coding Style</h1>

<p>Our coding style is informed by the <a href="https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md">.NET Runtime coding style</a> and the latest <a href="https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780135896464">&quot;Framework Design Guidelines&quot;</a> (currently third edition).</p>
<p>When establishing guidelines, we consider how they impact the ability to <a href="code_comprehension.html">comprehend the code</a>. The easier the code is to understand, the more likely it is correct, and the easier it is to maintain. There are a few core guiding principles:</p>
<ul>
<li>Code should be clear and unambiguous.</li>
<li>Code should be efficient and concise, using the minimum amount of code necessary to achieve the desired functionality without sacrificing readability or maintainability.</li>
<li>Guidelines are mutable where they inhibit our guiding principles.</li>
</ul>
<p>There are a few key things we strive for to attain our clarity goals:</p>
<ul>
<li>Minimal code block nesting.</li>
<li>Minimal scrolling for code blocks (almost no horizontal and limited vertical).</li>
<li>Minimal code visibility (via access modifiers, type nesting, and local functions).</li>
<li>All context captured in source (via code itself or comments).</li>
<li>Using modern language features to make the code easier to maintain and update in the longer term.</li>
</ul>
<p>A number of the following detailed guidelines are captured in our <a href="./../.editorconfig"><code>.editorconfig</code></a> files and also in our <a href="./../.github/copilot-instructions.md"><code>copilot-instructions.md</code></a> and to help get feedback on guidelines in Visual Studio and Visual Studio Code as well as better conformance with Copilot.</p>
<h3 id="spacing">Spacing</h3>
<p>Enabling viewing white space will make conforming to these rules easier. In VS: &quot;View White Space (Ctrl+R, Ctrl+W)&quot; or &quot;Edit -&gt; Advanced -&gt; View White Space&quot;. In VS Code the setting is &quot;Editor: Render Whitespace&quot;.</p>
<ol>
<li>Use four spaces of indentation (never use tabs). XML blocks should get a single space indent (this includes XML comments).</li>
<li>Lines should not have trailing white space or more than one space between code elements (<code>=</code> can be aligned when there is notable value in doing so, such as bit flag values).</li>
<li>Avoid more than one empty line at any time. For example, do not have two blank lines between members of a type.</li>
<li>Closing braces (<code>}</code>) on a line by themselves should be followed by a blank line unless the next line is also only a closing brace.</li>
</ol>
<h3 id="line-breaks">Line Breaks</h3>
<ol>
<li>Lines should be less than 120 characters long to limit horizontal scrolling in development tools. If it improves clarity, they can be slightly over, but they never should be longer than 150. Statements should not be broken into multiple lines when they fall under the 120 character limit.</li>
<li>When using expression body definitions (<code>=&gt;</code>) they should be on the same line if they fit, otherwise they should be broken after the <code>=&gt;</code> and indented once on the next line.</li>
<li>When breaking arguments to a method, all arguments should be indented on individual lines at one indent in.</li>
<li>When breaking logical statements, all logical operators (<code>&amp;&amp;</code>, <code>||</code>, etc.) at a given parenthetical scope should be indented on individual lines at one indent in.</li>
<li>When breaking ternary operators (<code>?:</code>), they should be broken into two singly indented lines, starting with <code>?</code> and <code>:</code>.</li>
</ol>
<details>
<summary>Code Samples</summary>
<p>More complicated line breaks:</p>
<pre><code class="lang-C#">if (_trackColumn != previousColumnIndex
    &amp;&amp; !(previousColumnIndex == -1 &amp;&amp; hti._col == _trackColumn)
    &amp;&amp; (dataGridViewColumnNext is null || _trackColumn != dataGridViewColumnNext.Index))
</code></pre>
<pre><code class="lang-C#">if (Focused
    &amp;&amp; !IsCurrentCellInEditMode
    &amp;&amp; (EditMode == DataGridViewEditMode.EditOnEnter
        || (EditMode != DataGridViewEditMode.EditProgrammatically &amp;&amp; CurrentCellInternal.EditType is null)))
</code></pre>
<p>Why <code>=&gt;</code> isn't at the beginning of a line:</p>
<pre><code class="lang-C#">// Further breaks logically align
internal bool SingleVerticalBorderAdded =&gt;
    !_layout.RowHeadersVisible
    &amp;&amp; (AdvancedCellBorderStyle.All == DataGridViewAdvancedCellBorderStyle.Single
        || CellBorderStyle == DataGridViewCellBorderStyle.SingleVertical);

// Same example, broken alignment
internal bool SingleVerticalBorderAdded
    =&gt; !_layout.RowHeadersVisible
    &amp;&amp; (AdvancedCellBorderStyle.All == DataGridViewAdvancedCellBorderStyle.Single
        || CellBorderStyle == DataGridViewCellBorderStyle.SingleVertical);

</code></pre>
</details>
<h3 id="code-blocks">Code Blocks</h3>
<ol>
<li>Use <a href="http://en.wikipedia.org/wiki/Indent_style#Allman_style">Allman style</a> braces, where each brace begins on a new line.</li>
<li><code>if</code> statements must use code blocks with the exception of single line parameter validation at the beginning of a method.</li>
<li><code>using</code> statements must use code blocks. <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0063">Simple using declarations</a> (which don't use code blocks) are preferred over using statements when possible. In the rare case that there are multiple <code>using</code> statements in a row, they should share a code block to reduce nesting.</li>
<li><code>fixed</code> statements must use code blocks. When there are multiple <code>using</code> statements in a row, they should share a code block to reduce nesting.</li>
<li><code>unsafe</code> should generally be applied to either whole methods or classes (when many methods are unsafe). When unsafe blocks are strictly necessary (say in an async or yield method) they must use code blocks.</li>
</ol>
<h3 id="comments">Comments</h3>
<ol>
<li>Code comments should be on their own line and precede the code they refer to. In condition blocks, comments should be inside the blocks (e.g., never before the <code>else</code>). Switch expression conditions have no blocks and should have the comment before the relevant condition line.</li>
<li>Avoid comments labeling the end of a block (never <code>if {} else {} // else</code>).</li>
<li>Methods and properties should have XML comments, not <code>//</code> comments. <code>public</code> API comments should align with the documentation on <a href="https://learn.microsoft.com">https://learn.microsoft.com</a>.</li>
<li>Do not replicate comments from base methods or interfaces. Use <code>&lt;inheritdoc/&gt;</code> or <code>&lt;inheritdoc cref=&quot;InterfaceOrBase.Member&quot;/&gt;</code> when docs aren't automatically inherited or you need to modify only a part of the documentation.</li>
<li>Avoid <code>/* ... */</code> comments.</li>
</ol>
<h3 id="general-naming">General Naming</h3>
<ol>
<li>Avoid abbreviations and type names for variable or property names (e.g. <code>Point firstPoint</code> not <code>pt1</code>).</li>
<li>Names should describe their use, not their type (e.g. <code>Rectangle bounds</code> over <code>Rectangle rectangle</code>).</li>
<li>Use <code>nameof(...)</code> instead of <code>&quot;...&quot;</code> whenever possible and relevant.</li>
</ol>
<h3 id="general-visibility">General Visibility</h3>
<ol>
<li>Always specify the visibility, even if it's the default (e.g. <code>private string _foo</code> not <code>string _foo</code>). Visibility should be the first modifier (e.g. <code>public abstract</code> not <code>abstract public</code>).</li>
</ol>
<h3 id="namespace-usings">Namespace Usings</h3>
<ol>
<li>Namespace <code>using</code>s should be specified at the top of the file, before <code>namespace</code> declarations, and should be sorted alphabetically, with the exception of <code>System.*</code> namespaces, which are to be placed on top of all others.</li>
<li>Global <code>using</code>s go should in a file called <code>globalusings.cs</code>.</li>
</ol>
<h3 id="namespaces">Namespaces</h3>
<ol>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/namespace">file-scoped namespaces</a>.</li>
<li>Files should be in subfolders that match the namespaces. Additional organizational folders can be created within namespace folders when necessary for clarity.</li>
</ol>
<h3 id="types">Types</h3>
<ol>
<li>All types should be in their own files. This includes nested types.</li>
<li>All internal and private classes should be sealed when they are not derived from.</li>
<li>Use Pascal Casing to name all types. The only exception is for interop types, which should match the native casing.</li>
<li>Consider <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors">primary constructors</a> for &quot;simple&quot; structs and classes where there is only one constructor with no logic other than field assignment.</li>
</ol>
<h3 id="fields">Fields</h3>
<ol>
<li>Type constants, statics, and fields should be specified at the top within the type declaration.</li>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/fundamentals/coding-style/identifier-names#camel-case"><code>_camelCase</code></a> for internal and private fields and use <code>readonly</code> where possible. Prefix instance fields with <code>_</code>, static fields with <code>s_</code> and thread static fields with <code>t_</code>.</li>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/fundamentals/coding-style/identifier-names#pascal-case"><code>PascalCasing</code></a> to name all constants. The only exception is for interop code where the constant value should match the naming in the native code.</li>
<li><code>public</code> or <code>internal</code> fields should not be used (use properties).</li>
<li><code>protected</code> properties should be preferred over fields.</li>
</ol>
<h3 id="properties">Properties</h3>
<ol>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/fundamentals/coding-style/identifier-names#pascal-case"><code>PascalCasing</code></a> to name all properties.</li>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties">auto-implemented properties</a> when possible.</li>
<li>Prefer methods over properties for expensive code or code with significant side effects.</li>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members">expression body definitions</a> (<code>=&gt;</code>) for single line getters and setters.</li>
</ol>
<h3 id="methods">Methods</h3>
<ol>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/fundamentals/coding-style/identifier-names#pascal-case"><code>PascalCasing</code></a> to name all methods.</li>
<li>Constructors should precede all other methods and properties.</li>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members">expression body definitions</a> (<code>=&gt;</code>) for single line methods.</li>
<li>Avoid methods with a single calling method. Use <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/local-functions">local functions</a>. Don't use a method at all in these cases if the logic is simple and not replicated.</li>
<li>Use static methods when instance fields are not accessed, and consider passing fields in to make methods static to clarify what a method modifies.</li>
<li>Prefer methods where top level blocks fit in a single editor screen (around 25 lines of code). Local functions can be used to break the logic into digestible chunks.</li>
<li>Keep block nesting to a minimum (preferably no more than 3 indents, 5 at the maximum). Use early outs and inverted conditionals to help manage nesting.</li>
<li>Exit (return) early from methods to reduce nesting.</li>
</ol>
<h3 id="variables">Variables</h3>
<ol>
<li>We never use <code>var</code> for <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/built-in-types">built-in types</a>, e.g. don't use <code>var count = 2</code>, instead use <code>int count = 2</code>. <code>var</code> should only be used when the type name inhibits code readability.</li>
<li><a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/new-operator#target-typed-new">Target-typed <code>new()</code></a> should be used to remove redundancy, not var. For example: <code>FileStream stream = new(...);</code>, not <code>var stream = new FileStream(...);</code>. Using target-typed <code>new()</code> for succinctness is allowed where the type is reasonably obvious, e.g. <code>Point[] points = [new(1, 2), new(5, 6)];</code></li>
<li><a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/collection-expressions">Collection expressions</a> are preferred, e.g. <code>Point[] points = [new(1, 2)];</code> over <code>Point[] points = new Point[] { new(1, 2) };</code>;</li>
</ol>
<h3 id="general">General</h3>
<ol>
<li>Use language keywords instead of BCL types (e.g. <code>int, string, float</code> instead of <code>Int32, String, Single</code>, etc.) for both type references as well as method calls (e.g. <code>int.Parse</code> instead of <code>Int32.Parse</code>).</li>
<li>Always use <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/tokens/interpolated">interpolated strings</a> when composing / formatting strings.</li>
<li>Use <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/tokens/raw-string">raw string literals</a> for multi-line strings.</li>
</ol>
<h3 id="conditions">Conditions</h3>
<ol>
<li>Prefer <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/conditional-operator">ternary operators</a> (<code>?:</code>) over <code>if .. else</code> when there is only one line in each clause.</li>
<li>Prefer <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/patterns">pattern matching</a> in conditions.</li>
<li>Prefer <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/null-coalescing-operator">null-coalescing</a> operators (<code>??</code> and <code>??=</code>).</li>
<li>Prefer <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/switch-expression">switch expressions</a> over switch statements where possible.</li>
</ol>
<h3 id="nullability">Nullability</h3>
<ol>
<li>Prefer <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/patterns">pattern matching</a> to check variable type and null state (e.g. <code>if (parameter is Form form)</code>, <code>if (manager.GetService&lt;IContainer&gt;() is { } container)</code>, etc.).</li>
<li>Using the postfix <code>!</code> <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/null-forgiving">null-forgiving operator</a> to override null analysis must always get a descriptive comment. Prefer to refactor code to avoid this where possible. If we do not control the code in question prefer to throw <code>ArgumentException</code> when an associated argument is known or <code>InvalidOperationException</code> otherwise. Do not let code fall into <code>NullReferenceException</code>.</li>
</ol>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/JeremyKuhne/touki/blob/main/docs/coding_guidelines.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      
          </div>
        </div>
      </footer>
      <script type="text/javascript" src="styles/darkmode.js"></script>    </div>

    <script type="text/javascript" src="styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
